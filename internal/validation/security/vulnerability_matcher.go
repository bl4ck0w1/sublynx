package security

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"sync"
	"time"
	"github.com/Masterminds/semver/v3"
	"github.com/sirupsen/logrus"
	"github.com/bl4ck0w1/sublynx/pkg/models"
)

type ObservedComponent struct {
	Vendor   string            `json:"vendor,omitempty"`
	Product  string            `json:"product,omitempty"`
	Name     string            `json:"name,omitempty"`    
	Version  string            `json:"version,omitempty"` 
	CPEs     []string          `json:"cpes,omitempty"`    
	Evidence map[string]string `json:"evidence,omitempty"`
}

type VulnRecord struct {
	ID          string   `json:"id"`                     
	Severity    string   `json:"severity,omitempty"`     
	CVSS        float64  `json:"cvss,omitempty"`         
	CWE         string   `json:"cwe,omitempty"`          
	Description string   `json:"description,omitempty"`  
	References  []string `json:"references,omitempty"`   
	CPEs []string `json:"cpes,omitempty"`
	Vendor          string `json:"vendor,omitempty"`
	Product         string `json:"product,omitempty"`
	VersionRule     string `json:"version_rule,omitempty"`     
	AllowNonSemver  bool   `json:"allow_non_semver,omitempty"` 
	MatchIfNoVersion bool  `json:"match_if_no_version,omitempty"`
}

type MatchResult struct {
	ID          string                 `json:"id"`
	Severity    models.SeverityLevel   `json:"severity"`
	CVSS        float64                `json:"cvss"`
	CWE         string                 `json:"cwe,omitempty"`
	Description string                 `json:"description,omitempty"`
	References  []string               `json:"references,omitempty"`
	MatchedBy   string                 `json:"matched_by"` 
	Confidence  float64                `json:"confidence"` 
	Component   ObservedComponent      `json:"component"`
	Record      VulnRecord             `json:"-"`
}

type VulnerabilityMatcher struct {
	logger *logrus.Logger

	mu        sync.RWMutex
	records   []VulnRecord
	indexCPE  map[string][]int                  
	indexProd map[string][]int                   
	cache     map[string][]MatchResult         
	metrics   struct{ totalMatches int64 }
}

func NewVulnerabilityMatcher(logger *logrus.Logger) *VulnerabilityMatcher {
	if logger == nil {
		logger = logrus.New()
	}
	return &VulnerabilityMatcher{
		logger:   logger,
		indexCPE: make(map[string][]int),
		indexProd: make(map[string][]int),
		cache:    make(map[string][]MatchResult),
	}
}

func (vm *VulnerabilityMatcher) LoadJSON(path string) error {
	vm.mu.Lock()
	defer vm.mu.Unlock()

	f, err := os.Open(filepath.Clean(path))
	if err != nil {
		return fmt.Errorf("open vuln db: %w", err)
	}
	defer f.Close()

	var recs []VulnRecord
	if err := json.NewDecoder(f).Decode(&recs); err != nil {
		return fmt.Errorf("decode vuln db: %w", err)
	}

	vm.records = recs
	vm.rebuildIndexesLocked()
	vm.cache = make(map[string][]MatchResult)
	vm.logger.Infof("Loaded %d vulnerability records from %s", len(recs), path)
	return nil
}

func (vm *VulnerabilityMatcher) AddRecords(recs ...VulnRecord) {
	vm.mu.Lock()
	defer vm.mu.Unlock()
	vm.records = append(vm.records, recs...)
	vm.rebuildIndexesLocked()
	vm.cache = make(map[string][]MatchResult)
}

func (vm *VulnerabilityMatcher) rebuildIndexesLocked() {
	vm.indexCPE = make(map[string][]int)
	vm.indexProd = make(map[string][]int)

	for i, r := range vm.records {
		for _, c := range r.CPEs {
			k := strings.ToLower(strings.TrimSpace(c))
			if k == "" {
				continue
			}
			vm.indexCPE[k] = append(vm.indexCPE[k], i)
		}
		if r.Vendor != "" && r.Product != "" {
			key := prodKey(r.Vendor, r.Product)
			vm.indexProd[key] = append(vm.indexProd[key], i)
		}
	}
}

func (vm *VulnerabilityMatcher) Match(ctx context.Context, comps []ObservedComponent) ([]MatchResult, error) {
	vm.mu.RLock()
	defer vm.mu.RUnlock()

	var results []MatchResult
	var mu sync.Mutex
	wg := sync.WaitGroup{}

	for _, c := range comps {
		c := normalizeComponent(c)
		wg.Add(1)
		go func() {
			defer wg.Done()

			select {
			case <-ctx.Done():
				return
			default:
			}

			key := cacheKey(c)
			if cached, ok := vm.cache[key]; ok {
				mu.Lock()
				results = append(results, cached...)
				mu.Unlock()
				return
			}
			m := vm.matchComponent(c)
			vm.mu.RUnlock()
			vm.mu.Lock()
			vm.cache[key] = m
			vm.mu.Unlock()
			vm.mu.RLock()
			mu.Lock()
			results = append(results, m...)
			mu.Unlock()
		}()
	}

	wg.Wait()
	sort.SliceStable(results, func(i, j int) bool {
		if results[i].Confidence != results[j].Confidence {
			return results[i].Confidence > results[j].Confidence
		}
		if results[i].Severity != results[j].Severity {
			return results[i].Severity > results[j].Severity
		}
		return results[i].ID < results[j].ID
	})
	return results, nil
}

func (vm *VulnerabilityMatcher) matchComponent(c ObservedComponent) []MatchResult {
	seen := make(map[string]bool)
	var out []MatchResult
	for _, cpe := range c.CPEs {
		cpe = strings.ToLower(strings.TrimSpace(cpe))
		if cpe == "" {
			continue
		}
		out = append(out, vm.collectMatchesByCPE(c, cpe, seen, 1.0)...)
		parts := strings.Split(cpe, ":")
		if len(parts) >= 5 {
			prefix := strings.Join(parts[:5], ":")
			out = append(out, vm.collectMatchesByCPEPrefix(c, prefix, seen, 0.9)...)
		}
	}

	vendor := strings.ToLower(strings.TrimSpace(c.Vendor))
	product := strings.ToLower(strings.TrimSpace(c.Product))
	if vendor != "" && product != "" {
		key := prodKey(vendor, product)
		if idxs, ok := vm.indexProd[key]; ok {
			for _, i := range idxs {
				rec := vm.records[i]
				okMatch, conf := versionMatches(rec.VersionRule, c.Version, rec.AllowNonSemver, rec.MatchIfNoVersion)
				if okMatch {
					m := vm.makeResult(rec, c, "vendor_product", conf)
					if !seen[m.ID] {
						out = append(out, m)
						seen[m.ID] = true
					}
				}
			}
		}
	}

	if vendor == "" || product == "" {
		guessVendor, guessProduct := guessFromName(c.Name)
		if guessVendor != "" && guessProduct != "" {
			key := prodKey(guessVendor, guessProduct)
			if idxs, ok := vm.indexProd[key]; ok {
				for _, i := range idxs {
					rec := vm.records[i]
					okMatch, conf := versionMatches(rec.VersionRule, c.Version, rec.AllowNonSemver, rec.MatchIfNoVersion)
					if okMatch {
						m := vm.makeResult(rec, c, "heuristic", conf*0.8)
						if !seen[m.ID] {
							out = append(out, m)
							seen[m.ID] = true
						}
					}
				}
			}
		}
	}

	return out
}

func (vm *VulnerabilityMatcher) collectMatchesByCPE(c ObservedComponent, cpe string, seen map[string]bool, baseConf float64) []MatchResult {
	var out []MatchResult
	if idxs, ok := vm.indexCPE[cpe]; ok {
		for _, i := range idxs {
			rec := vm.records[i]
			m := vm.makeResult(rec, c, "cpe", baseConf)
			if !seen[m.ID] {
				out = append(out, m)
				seen[m.ID] = true
			}
		}
	}
	return out
}

func (vm *VulnerabilityMatcher) collectMatchesByCPEPrefix(c ObservedComponent, prefix string, seen map[string]bool, baseConf float64) []MatchResult {
	var out []MatchResult
	for k, idxs := range vm.indexCPE {
		if strings.HasPrefix(k, prefix) {
			for _, i := range idxs {
				rec := vm.records[i]
				m := vm.makeResult(rec, c, "cpe_prefix", baseConf)
				if !seen[m.ID] {
					out = append(out, m)
					seen[m.ID] = true
				}
			}
		}
	}
	return out
}

func (vm *VulnerabilityMatcher) makeResult(rec VulnRecord, c ObservedComponent, matchedBy string, confidence float64) MatchResult {
	return MatchResult{
		ID:          rec.ID,
		Severity:    mapSeverity(rec.Severity),
		CVSS:        rec.CVSS,
		CWE:         rec.CWE,
		Description: rec.Description,
		References:  rec.References,
		MatchedBy:   matchedBy,
		Confidence:  clamp(confidence, 0, 1),
		Component:   c,
		Record:      rec,
	}
}

func prodKey(vendor, product string) string {
	return strings.ToLower(strings.TrimSpace(vendor)) + "::" + strings.ToLower(strings.TrimSpace(product))
}

func cacheKey(c ObservedComponent) string {
	return fmt.Sprintf("%s|%s|%s|%s|%v", strings.ToLower(c.Vendor), strings.ToLower(c.Product), strings.ToLower(c.Name), c.Version, c.CPEs)
}

func clamp(v, lo, hi float64) float64 {
	if v < lo {
		return lo
	}
	if v > hi {
		return hi
	}
	return v
}

func normalizeComponent(c ObservedComponent) ObservedComponent {
	if c.Vendor == "" || c.Product == "" {
		v, p := guessFromName(c.Name)
		if c.Vendor == "" {
			c.Vendor = v
		}
		if c.Product == "" {
			c.Product = p
		}
	}
	c.Vendor, c.Product = canonicalizeVendorProduct(c.Vendor, c.Product)
	for i := range c.CPEs {
		c.CPEs[i] = strings.ToLower(strings.TrimSpace(c.CPEs[i]))
	}
	return c
}

var nameMap = []struct {
	re     *regexp.Regexp
	vendor string
	prod   string
}{
	{regexp.MustCompile(`(?i)\bnginx\b`), "nginx", "nginx"},
	{regexp.MustCompile(`(?i)\bapache\b|\bhttpd\b`), "apache", "http_server"},
	{regexp.MustCompile(`(?i)\bopenresty\b`), "openresty", "openresty"},
	{regexp.MustCompile(`(?i)\blighttpd\b`), "lighttpd", "lighttpd"},
	{regexp.MustCompile(`(?i)\biis\b|\bmicrosoft-httpapi\b`), "microsoft", "iis"},
	{regexp.MustCompile(`(?i)\bjetty\b`), "eclipse", "jetty"},
	{regexp.MustCompile(`(?i)\btomcat\b`), "apache", "tomcat"},
	{regexp.MustCompile(`(?i)\bgunicorn\b`), "gunicorn", "gunicorn"},
	{regexp.MustCompile(`(?i)\buvicorn\b`), "encode", "uvicorn"},
	{regexp.MustCompile(`(?i)\bopenssl\b`), "openssl", "openssl"},
}

func guessFromName(name string) (string, string) {
	for _, n := range nameMap {
		if n.re.MatchString(name) {
			return n.vendor, n.prod
		}
	}
	return "", ""
}

func canonicalizeVendorProduct(vendor, product string) (string, string) {
	v := strings.ToLower(strings.TrimSpace(vendor))
	p := strings.ToLower(strings.TrimSpace(product))
	switch {
	case v == "apache" && (p == "httpd" || p == "apache" || p == "apache_http_server"):
		p = "http_server"
	}
	return v, p
}

func mapSeverity(s string) models.SeverityLevel {
	switch strings.ToUpper(strings.TrimSpace(s)) {
	case "CRITICAL":
		return models.SeverityCritical
	case "HIGH":
		return models.SeverityHigh
	case "MEDIUM":
		return models.SeverityMedium
	case "LOW":
		return models.SeverityLow
	default:
		return models.SeverityInfo
	}
}

func versionMatches(rule, version string, allowNonSemver, matchIfNoVersion bool) (bool, float64) {
	rule = strings.TrimSpace(rule)
	version = strings.TrimSpace(version)
	if rule == "" {
		if version == "" {
			return true, 0.6
		}
		return true, 0.8
	}

	if version == "" {
		if matchIfNoVersion {
			return true, 0.55
		}
		return false, 0
	}

	raw := strings.TrimPrefix(version, "v")
	ver, err := semver.NewVersion(raw)
	constraints, cErr := semver.NewConstraint(rule)
	if err == nil && cErr == nil {
		if constraints.Check(ver) {
			return true, 0.9
		}
		return false, 0
	}

	if allowNonSemver {
		if strings.Contains(strings.ToLower(rule), strings.ToLower(raw)) {
			return true, 0.6
		}
		if strings.Contains(rule, "<") && !strings.Contains(rule, ">") {
			return true, 0.5
		}
	}

	return false, 0
}

func (vm *VulnerabilityMatcher) GetStats() map[string]interface{} {
	vm.mu.RLock()
	defer vm.mu.RUnlock()

	return map[string]interface{}{
		"records":        len(vm.records),
		"cpe_index":      len(vm.indexCPE),
		"product_index":  len(vm.indexProd),
		"cache_entries":  len(vm.cache),
	}
}

func ExtractComponentsFromHTTPAnalysis(ha *models.HTTPAnalysis) []ObservedComponent {
	if ha == nil {
		return nil
	}
	var out []ObservedComponent

	if ha.Server != "" {
		vendor, product := guessFromName(ha.Server)
		out = append(out, ObservedComponent{
			Vendor:   vendor,
			Product:  product,
			Name:     ha.Server,
			Version:  extractVersion(ha.Server),
			Evidence: map[string]string{"header": "Server", "value": ha.Server},
		})
	}
	if xpb, ok := ha.Response.Headers["X-Powered-By"]; ok && xpb != "" {
		vendor, product := guessFromName(xpb)
		out = append(out, ObservedComponent{
			Vendor:   vendor,
			Product:  product,
			Name:     xpb,
			Version:  extractVersion(xpb),
			Evidence: map[string]string{"header": "X-Powered-By", "value": xpb},
		})
	}

	for _, t := range ha.Technologies {
		vendor, product := guessFromName(t)
		out = append(out, ObservedComponent{
			Vendor:   vendor,
			Product:  product,
			Name:     t,
			Version:  extractVersion(t),
			Evidence: map[string]string{"source": "content_technology", "value": t},
		})
	}

	return out
}

func ExtractComponentsFromTLSAnalysis(_ *models.TLSAnalysis) []ObservedComponent {
	return nil
}

var versionRe = regexp.MustCompile(`\b(\d+(?:\.\d+){0,3})\b`)

func extractVersion(s string) string {
	m := versionRe.FindStringSubmatch(s)
	if len(m) > 1 {
		return m[1]
	}
	return ""
}
